{
  "curriculum": "cs2013",
  "knowledge-areas": [
    {
      "ka": "Systems Fundamentals",
      "short_ka": "SF",
      "units": [
        {
          "ku": "Computational Paradigms",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "3"
            }
          ],
          "topics": [
            {
              "topic": "Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections; Datapath + Control + Memory)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions, minimization, sum of product forms",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Application-level sequential processing: single thread",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Simple application-level parallel processing: request level (web services/client-server/distributed), single thread per server, multiple threads with multiple servers",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Basic concept of pipelining, overlapped processing stages",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Basic concept of scaling: going faster vs. handling larger problems",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "List commonly encountered patterns of how computations are organized.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe the basic building blocks of computers and their role in the historical development of computer architecture.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Articulate the differences between single thread vs. multiple thread, single server vs. multiple server models, motivated by real world examples (e.g., cooking recipes, lines for multiple teller machines and couples shopping for food).",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Articulate the concept of strong vs. weak scaling, i.e., how performance is affected by scale of problem vs. scale of resources to solve the problem. This can be motivated by the simple, real-world examples.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Design a simple logic circuit using the fundamental building blocks of logic design.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Use tools for capture, synthesis, and simulation to evaluate a logic design.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "7",
              "outcome": "Write a simple sequential problem and a simple parallel version of the same program.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "8",
              "outcome": "Evaluate performance of simple sequential and parallel versions of a program with different problem sizes, and be able to describe the speed-ups achieved.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Cross-Layer Communications",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "3"
            }
          ],
          "topics": [
            {
              "topic": "Programming abstractions, interfaces, use of libraries",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Distinction between Application and OS services, Remote Procedure Call",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Application-Virtual Machine Interaction",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Reliability",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Describe how computing systems are constructed of layers upon layers, based on separation of concerns, with well-defined interfaces, hiding details of low layers from the higher layers.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe how hardware, VM, OS, and applications are additional layers of interpretation/processing.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Describe the mechanisms of how errors are detected, signaled back, and handled through the layers.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Construct a simple program using methods of layering, error detection and recovery, and reflection of error status across layers.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Find bugs in a layered program by using tools for program tracing, single stepping, and debugging.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "State and State Machines",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "6"
            }
          ],
          "topics": [
            {
              "topic": "Digital vs. Analog/Discrete vs. Continuous Systems",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Simple logic gates, logical expressions, Boolean logic simplification",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Clocks, State, Sequencing",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Combinational Logic, Sequential Logic, Registers, Memories",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Computers and Network Protocols as examples of state machines",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Describe computations as a system characyterized by a known set of configurations with transitions from one unique configuration (state) to another (state).",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe the distinction between systems whose output is only a function of their input (Combinational) and those with memory/history (Sequential).",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Describe a computer as a state machine that interprets machine instructions.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Explain how a program or network protocol can also be expressed as a state machine, and that alternative representations for the same computation can exist.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Develop state machine descriptions for simple problem statement solutions (e.g., traffic light sequencing, pattern recognizers).",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Derive time-series behavior of a state machine from its state machine representation.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Parallelism",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "3"
            }
          ],
          "topics": [
            {
              "topic": "Sequential vs. parallel processing",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Parallel programming vs. concurrent programming",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Request parallelism vs. Task parallelism",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Client-Server/Web Services, Thread (Fork-Join), Pipelining",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Multicore architectures and hardware support for synchronization",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "For a given program, distinguish between its sequential and parallel execution, and the performance implications thereof.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Demonstrate on an execution time line that parallelism events and operations can take place simultaneously (i.e., at the same time). Explain how work can be performed in less elapsed time if this can be exploited.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Explain other uses of parallelism, such as for reliability/redundancy of execution.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Define the differences between the concepts of Instruction Parallelism, Data Parallelism, Thread Parallelism/Multitasking, Task/Request Parallelism.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Write more than one parallel program (e.g., one simple parallel program in more than one parallel programming paradigm; a simple parallel program that manages shared resources through synchronization primitives; a simple parallel program that performs simultaneous operation on partitioned data through task parallel (e.g., parallel search terms; a simple parallel program that performs step-by-step pipeline processing through message passing).",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Use performance tools to measure speed-up achieved by parallel programs in terms of both problem size and number of resources.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Evaluation",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "3"
            }
          ],
          "topics": [
            {
              "topic": "Performance figures of merit",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Workloads and representative benchmarks, and methods of collecting and analyzing performance figures of merit",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "CPI (Cycles per Instruction) equation as tool for understanding tradeoffs in the design of instruction sets, processor pipelines, and memory system organizations.",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Amdahl\u2019s Law: the part of the computation that cannot be sped up limits the effect of the parts that can",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Explain how the components of system architecture contribute to improving its performance.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe Amdahl\u2019s law and discuss its limitations.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Design and conduct a performance-oriented experiment.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Use software tools to profile and measure program performance.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Resource Allocation and Scheduling",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "2"
            }
          ],
          "topics": [
            {
              "topic": "Kinds of resources (e.g., processor share, memory, disk, net bandwidth)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Kinds of scheduling (e.g., first-come, priority)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Advantages of fair scheduling, preemptive scheduling",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Define how finite computer resources (e.g., processor share, memory, storage and network bandwidth) are managed by their careful allocation to existing entities.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe the scheduling algorithms by which resources are allocated to competing entities, and the figures of merit by which these algorithms are evaluated, such as fairness.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Implement simple schedule algorithms.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Use figures of merit of alternative scheduler implementations.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Proximity",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "3"
            }
          ],
          "topics": [
            {
              "topic": "Speed of light and computers (one foot per nanosecond vs. one GHz clocks)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Latencies in computer systems: memory vs. disk latencies vs. across the network memory",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Caches and the effects of spatial and temporal locality on performance in processors and systems",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Caches and cache coherency in databases, operating systems, distributed systems, and computer architecture",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Introduction into the processor memory hierarchy and the formula for average memory access time",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Explain the importance of locality in determining performance.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe why things that are close in space take less time to access.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Calculate average memory access time and describe the tradeoffs in memory hierarchy performance in terms of capacity, miss/hit rate, and access time.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Virtualization and Isolation",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "2"
            }
          ],
          "topics": [
            {
              "topic": "Rationale for protection and predictable performance",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Levels of indirection, illustrated by virtual memory for managing physical memory resources",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Methods for implementing virtual memory and virtual machines",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Explain why it is important to isolate and protect the execution of individual programs and environments that share common underlying resources.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe how the concept of indirection can create the illusion of a dedicated machine and its resources even when physically shared among multiple programs and environments.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Measure the performance of two application instances running on separate virtual machines, and determine the effect of performance isolation.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Reliability through Redundancy",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "2"
            }
          ],
          "topics": [
            {
              "topic": "Distinction between bugs and faults",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Redundancy through check and retry",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Redundancy through redundant encoding (error correcting codes, CRC, FEC)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Duplication/mirroring/replicas",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Other approaches to fault tolerance and availability",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Explain the distinction between program errors, system errors, and hardware faults (e.g., bad memory) and exceptions (e.g., attempt to divide by zero).",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Articulate the distinction between detecting, handling, and recovering from faults, and the methods for their implementation.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Describe the role of error correcting codes in providing error checking and correction techniques in memories, storage, and networks.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Apply simple algorithms for exploiting redundant information for the purposes of data correction.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Compare different error detection and correction methods for their data overhead, implementation complexity, and relative execution time for encoding, detecting, and correcting errors.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Quantitative Evaluation",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Analytical tools to guide quantitative evaluation",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Order of magnitude analysis (Big-Oh notation)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Analysis of slow and fast paths of a system",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Events on their effect on performance (e.g., instruction stalls, cache misses, page faults)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Understanding layered systems, workloads, and platforms, their implications for performance, and the challenges they represent for evaluation",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Microbenchmarking pitfalls",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Explain the circumstances in which a given figure of system performance metric is useful.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Explain the inadequacies of benchmarks as a measure of system performance.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Use limit studies or simple calculations to produce order-of-magnitude estimates for a given performance metric in a given context.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Conduct a performance experiment on a layered system to determine the effect of a system parameter on figure of system performance.",
              "mastery": "Assessment",
              "tier": null,
              "xref": null
            }
          ]
        }
      ],
      "references": []
    },
    {
      "ka": "Programming Languages",
      "short_ka": "PL",
      "units": [
        {
          "ku": "Object-Oriented Programming",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "4"
            },
            {
              "tier": "Core-Tier2",
              "hours": "6"
            }
          ],
          "topics": [
            {
              "topic": "Object-oriented design",
              "tier": "Core-Tier1",
              "subtopics": [
                "Decomposition into objects carrying state and having behavior",
                "Class-hierarchy design for modeling"
              ]
            },
            {
              "topic": "Definition of classes: fields, methods, and constructors",
              "tier": "Core-Tier1",
              "subtopics": []
            },
            {
              "topic": "Subclasses, inheritance, and method overriding",
              "tier": "Core-Tier1",
              "subtopics": []
            },
            {
              "topic": "Dynamic dispatch: definition of method-call",
              "tier": "Core-Tier1",
              "subtopics": []
            },
            {
              "topic": "Subtyping (cross-reference PL/Type Systems)",
              "tier": "Core-Tier2",
              "subtopics": [
                "Subtype polymorphism; implicit upcasts in typed languages",
                "Notion of behavioral replacement: subtypes acting like supertypes",
                "Relationship between subtyping and inheritance"
              ]
            },
            {
              "topic": "Object-oriented idioms for encapsulation",
              "tier": "Core-Tier2",
              "subtopics": [
                "Privacy and visibility of class members",
                "Interfaces revealing only method signatures",
                "Abstract base classes"
              ]
            },
            {
              "topic": "Using collection classes, iterators, and other common library components",
              "tier": "Core-Tier2",
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Design and implement a class.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Use subclassing to design simple class hierarchies that allow code to be reused for distinct subclasses.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Correctly reason about control flow in a program using dynamic dispatch.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Compare and contrast (1) the procedural/functional approach (defining a function for each operation with the function body providing a case for each data variant) and (2) the object-oriented approach (defining a class for each data variant with the class definition providing a method for each operation). Understand both as defining a matrix of operations and variants.",
              "mastery": "Assessment",
              "tier": "Core-Tier1",
              "xref": "This outcome also appears in PL/Functional Programming."
            },
            {
              "number": "5",
              "outcome": "Explain the relationship between object-oriented inheritance (code-sharing and overriding) and subtyping (the idea of a subtype being usable in a context that expects the supertype).",
              "mastery": "Familiarity",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Use object-oriented encapsulation mechanisms such as interfaces and private members.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "7",
              "outcome": "Define and use iterators and other operations on aggregates, including operations that take functions as arguments, in multiple programming languages, selecting the most natural idioms for each language.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": "This outcome also appears in PL/Functional Programming."
            }
          ]
        },
        {
          "ku": "Functional Programming",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "3"
            },
            {
              "tier": "Core-Tier2",
              "hours": "4"
            }
          ],
          "topics": [
            {
              "topic": "Effect-free programming",
              "tier": "Core-Tier1",
              "subtopics": [
                "Function calls have no side effects, facilitating compositional reasoning",
                "Variables are immutable, preventing unexpected changes to program data by other code",
                "Data can be freely aliased or copied without introducing unintended effects from mutation"
              ]
            },
            {
              "topic": "Processing structured data (e.g., trees) via functions with cases for each data variant",
              "tier": "Core-Tier1",
              "subtopics": [
                "Associated language constructs such as discriminated unions and pattern-matching over them",
                "Functions defined over compound data in terms of functions applied to the constituent pieces"
              ]
            },
            {
              "topic": "First-class functions (taking, returning, and storing functions)",
              "tier": "Core-Tier1",
              "subtopics": []
            },
            {
              "topic": "Function closures (functions using variables in the enclosing lexical environment)",
              "tier": "Core-Tier2",
              "subtopics": [
                "Basic meaning and definition -- creating closures at run-time by capturing the environment",
                "Canonical idioms: call-backs, arguments to iterators, reusable code via function arguments",
                "Using a closure to encapsulate data in its environment",
                "Currying and partial application"
              ]
            },
            {
              "topic": "Defining higher-order operations on aggregates, especially map, reduce/fold, and filter",
              "tier": "Core-Tier2",
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Write basic algorithms that avoid assigning to mutable state or considering reference equality.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Write useful functions that take and return other functions.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Compare and contrast (1) the procedural/functional approach (defining a function for each operation with the function body providing a case for each data variant) and (2) the object-oriented approach (defining a class for each data variant with the class definition providing a method for each operation). Understand both as defining a matrix of operations and variants.",
              "mastery": "Assessment",
              "tier": "Core-Tier1",
              "xref": "This outcome also appears in PL/Object-Oriented Programming."
            },
            {
              "number": "4",
              "outcome": "Correctly reason about variables and lexical scope in a program using function closures.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Use functional encapsulation mechanisms such as closures and modular interfaces.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Define and use iterators and other operations on aggregates, including operations that take functions as arguments, in multiple programming languages, selecting the most natural idioms for each language.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": "This outcome also appears in PL/Object-Oriented Programming."
            }
          ]
        },
        {
          "ku": "Event-Driven and Reactive Programming",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "2"
            }
          ],
          "topics": [
            {
              "topic": "Events and event handlers",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Canonical uses such as GUIs, mobile devices, robots, servers",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Using a reactive framework",
              "tier": null,
              "subtopics": [
                "Defining event handlers/listeners",
                "Main event loop not under event-handler-writer\u2019s control"
              ]
            },
            {
              "topic": "Externally-generated events and program-generated events",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Separation of model, view, and controller",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Write event handlers for use in reactive systems, such as GUIs.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Explain why an event-driven programming style is natural in domains where programs react to external events.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Describe an interactive system in terms of a model, a view, and a controller.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Basic Type Systems",
          "tiers": [
            {
              "tier": "Core-Tier1",
              "hours": "1"
            },
            {
              "tier": "Core-Tier2",
              "hours": "4"
            }
          ],
          "topics": [
            {
              "topic": "A type as a set of values together with a set of operations",
              "tier": "Core-Tier1",
              "subtopics": [
                "Primitive types (e.g., numbers, Booleans)",
                "Compound types built from other types (e.g., records, unions, arrays, lists, functions, references)"
              ]
            },
            {
              "topic": "Association of types to variables, arguments, results, and fields",
              "tier": "Core-Tier1",
              "subtopics": []
            },
            {
              "topic": "Type safety and errors caused by using values inconsistently given their intended types",
              "tier": "Core-Tier1",
              "subtopics": []
            },
            {
              "topic": "Goals and limitations of static typing",
              "tier": "Core-Tier1",
              "subtopics": [
                "Eliminating some classes of errors without running the program",
                "Undecidability means static analysis must conservatively approximate program behavior"
              ]
            },
            {
              "topic": "Generic types (parametric polymorphism)",
              "tier": "Core-Tier2",
              "subtopics": [
                "Definition",
                "Use for generic libraries such as collections",
                "Comparison with ad hoc polymorphism (overloading) and subtype polymorphism"
              ]
            },
            {
              "topic": "Complementary benefits of static and dynamic typing",
              "tier": "Core-Tier2",
              "subtopics": [
                "Errors early vs. errors late/avoided",
                "Enforce invariants during code development and code maintenance vs. postpone typing decisions while prototyping and conveniently allow flexible coding patterns such as heterogeneous collections",
                "Avoid misuse of code vs. allow more code reuse",
                "Detect incomplete programs vs. allow incomplete programs to run"
              ]
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "For both a primitive and a compound type, informally describe the values that have that type.",
              "mastery": "Familiarity",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "2",
              "outcome": "For a language with a static type system, describe the operations that are forbidden statically, such as passing the wrong type of value to a function or method.",
              "mastery": "Familiarity",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Describe examples of program errors detected by a type system.",
              "mastery": "Familiarity",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "4",
              "outcome": "For multiple programming languages, identify program properties checked statically and program properties checked dynamically.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Give an example program that does not type-check in a particular language and yet would have no error if run.",
              "mastery": "Familiarity",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Use types and type-error messages to write and debug programs.",
              "mastery": "Usage",
              "tier": "Core-Tier1",
              "xref": null
            },
            {
              "number": "7",
              "outcome": "Explain how typing rules define the set of operations that are legal for a type.",
              "mastery": "Familiarity",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "8",
              "outcome": "Write down the type rules governing the use of a particular compound type.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "9",
              "outcome": "Explain why undecidability requires type systems to conservatively approximate program behavior.",
              "mastery": "Familiarity",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "10",
              "outcome": "Define and use program pieces (such as functions, classes, methods) that use generic types, including for collections.",
              "mastery": "Usage",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "11",
              "outcome": "Discuss the differences among generics, subtyping, and overloading.",
              "mastery": "Familiarity",
              "tier": "Core-Tier2",
              "xref": null
            },
            {
              "number": "12",
              "outcome": "Explain multiple benefits and limitations of static typing in writing, maintaining, and debugging software.",
              "mastery": "Familiarity",
              "tier": "Core-Tier2",
              "xref": null
            }
          ]
        },
        {
          "ku": "Program Representation",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "1"
            }
          ],
          "topics": [
            {
              "topic": "Programs that take (other) programs as input such as interpreters, compilers, type-checkers, documentation generators",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Abstract syntax trees; contrast with concrete syntax",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Data structures to represent code for execution, translation, or transmission",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Explain how programs that process other programs treat the other programs as their input data.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe an abstract syntax tree for a small language.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Describe the benefits of having program representations other than strings of source code.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Write a program to process some representation of code for some purpose, such as an interpreter, an expression optimizer, or a documentation generator.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Language Translation and Execution",
          "tiers": [
            {
              "tier": "Core-Tier2",
              "hours": "3"
            }
          ],
          "topics": [
            {
              "topic": "Interpretation vs. compilation to native code vs. compilation to portable intermediate representation",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Language translation pipeline: parsing, optional type-checking, translation, linking, execution",
              "tier": null,
              "subtopics": [
                "Execution as native code or within a virtual machine",
                "Alternatives like dynamic loading and dynamic (or \u201cjust-in-time\u201d) code generation"
              ]
            },
            {
              "topic": "Run-time representation of core language constructs such as objects (method tables) and first-class functions (closures)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Run-time layout of memory: call-stack, heap, static data",
              "tier": null,
              "subtopics": [
                "Implementing loops, recursion, and tail calls"
              ]
            },
            {
              "topic": "Memory management",
              "tier": null,
              "subtopics": [
                "Manual memory management: allocating, de-allocating, and reusing heap memory",
                "Automated memory management: garbage collection as an automated technique using the notion",
                "f reachability"
              ]
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Distinguish a language definition (what constructs mean) from a particular language implementation (compiler vs. interpreter, run-time representation of data objects, etc.).",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Distinguish syntax and parsing from semantics and evaluation.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Sketch a low-level run-time representation of core language constructs, such as objects or closures.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Explain how programming language implementations typically organize memory into global data, text, heap, and stack sections and how features such as recursion and memory management map to this memory model.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Identify and fix memory leaks and dangling-pointer dereferences.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Discuss the benefits and limitations of garbage collection, including the notion of reachability.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Syntax Analysis",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Scanning (lexical analysis) using regular expressions",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Parsing strategies including top-down (e.g., recursive descent, Earley parsing, or LL) and bottom-up (e.g., backtracking or LR) techniques; role of context-free grammars",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Generating scanners and parsers from declarative specifications",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Use formal grammars to specify the syntax of languages.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Use declarative tools to generate parsers and scanners.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Identify key issues in syntax definitions: ambiguity, associativity, precedence.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Compiler Semantic Analysis",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "High-level program representations such as abstract syntax trees",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Scope and binding resolution",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Type checking",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Declarative specifications such as attribute grammars",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Implement context-sensitive, source-level static analyses such as type-checkers or resolving identifiers to identify their binding occurrences.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Describe semantic analyses using an attribute grammar.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Code Generation",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Procedure calls and method dispatching",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Separate compilation; linking",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Instruction selection",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Instruction scheduling",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Register allocation",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Peephole optimization",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Identify all essential steps for automatically converting source code into assembly or other low-level languages.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Generate the low-level code for calling functions/methods in modern languages.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Discuss why separate compilation requires uniform calling conventions.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Discuss why separate compilation limits optimization because of unknown effects of calls.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Discuss opportunities for optimization introduced by naive translation and approaches for achieving optimization, such as instruction selection, instruction scheduling, register allocation, and peephole optimization.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Runtime Systems",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Dynamic memory management approaches and techniques: malloc/free, garbage collection (mark-sweep, copying, reference counting), regions (also known as arenas or zones)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Data layout for objects and activation records",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Just-in-time compilation and dynamic recompilation",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Other common features of virtual machines, such as class loading, threads, and security.",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Compare the benefits of different memory-management schemes, using concepts such as fragmentation, locality, and memory overhead.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Discuss benefits and limitations of automatic memory management.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Explain the use of metadata in run-time representations of objects and activation records, such as class pointers, array lengths, return addresses, and frame pointers.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Discuss advantages, disadvantages, and difficulties of just-in-time and dynamic recompilation.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Identify the services provided by modern language run-time systems.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Static Analysis",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Relevant program representations, such as basic blocks, control-flow graphs, def-use chains, and static single assignment",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Undecidability and consequences for program analysis",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Flow-insensitive analyses, such as type-checking and scalable pointer and alias analyses",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Flow-sensitive analyses, such as forward and backward dataflow analyses",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Path-sensitive analyses, such as software model checking",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Tools and frameworks for defining analyses",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Role of static analysis in program optimization",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Role of static analysis in (partial) verification and bug-finding",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Define useful static analyses in terms of a conceptual framework such as dataflow analysis.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Explain why non-trivial sound static analyses must be approximate.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Communicate why an analysis is correct (sound and terminating).",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Distinguish \u201cmay\u201d and \u201cmust\u201d analyses.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Explain why potential aliasing limits sound program analysis and how alias analysis can help.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Use the results of a static analysis for program optimization and/or partial program correctness.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Advanced Programming Constructs",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Lazy evaluation and infinite streams",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Control Abstractions: Exception Handling, Continuations, Monads",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Object-oriented abstractions: Multiple inheritance, Mixins, Traits, Multimethods",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Metaprogramming: Macros, Generative programming, Model-based development",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Module systems",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "String manipulation via pattern-matching (regular expressions)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Dynamic code evaluation (\u201ceval\u201d)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Language support for checking assertions, invariants, and pre/post-conditions",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Use various advanced programming constructs and idioms correctly.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Discuss how various advanced programming constructs aim to improve program structure, software quality, and programmer productivity.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Discuss how various advanced programming constructs interact with the definition and implementation of other language features.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Concurrency and Parallelism",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Constructs for thread-shared variables and shared-memory synchronization",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Actor models",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Futures",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Language support for data parallelism",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Models for passing messages between sequential processes",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Effect of memory-consistency models on language semantics and correct code generation",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Write correct concurrent programs using multiple programming models, such as shared memory, actors, futures, and data-parallelism primitives.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Use a message-passing model to analyze a communication protocol.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Explain why programming languages do not guarantee sequential consistency in the presence of data races and what programmers must do as a result.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Type Systems",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Compositional type constructors, such as product types (for aggregates), sum types (for unions), function types, quantified types, and recursive types",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Type checking",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Type safety as preservation plus progress",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Type inference",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Static overloading",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Define a type system precisely and compositionally.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "For various foundational type constructors, identify the values they describe and the invariants they enforce.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Precisely specify the invariants preserved by a sound type system.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Prove type safety for a simple language in terms of preservation and progress theorems.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Implement a unification-based type-inference algorithm for a simple language.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Explain how static overloading and associated resolution algorithms influence the dynamic behavior of programs.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Formal Semantics",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Syntax vs. semantics",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Lambda Calculus",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Approaches to semantics: Operational, Denotational, Axiomatic",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Proofs by induction over language semantics",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Formal definitions and proofs for type systems (cross-reference PL/Type Systems)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Parametricity (cross-reference PL/Type Systems)",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Using formal semantics for systems modeling",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Give a formal semantics for a small language.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Write a lambda-calculus program and show its evaluation to a normal form.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Discuss the different approaches of operational, denotational, and axiomatic semantics.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Use induction to prove properties of all programs in a language.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Use induction to prove properties of all programs in a language that are well-typed according to a formally defined type system.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "6",
              "outcome": "Use parametricity to establish the behavior of code given only its type.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "7",
              "outcome": "Use formal semantics to build a formal model of a software system other than a programming language.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Language Pragmatics",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Principles of language design such as orthogonality",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Evaluation order, precedence, and associativity",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Eager vs. delayed evaluation",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Defining control and iteration constructs",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "External calls and system libraries",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Discuss the role of concepts such as orthogonality and well-chosen defaults in language design.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Use crisp and objective criteria for evaluating language-design decisions.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "3",
              "outcome": "Give an example program whose result can differ under different rules for evaluation order, precedence, or associativity.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "4",
              "outcome": "Show uses of delayed evaluation, such as user-defined control abstractions.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            },
            {
              "number": "5",
              "outcome": "Discuss the need for allowing calls to external calls and system libraries and the consequences for language implementation.",
              "mastery": "Familiarity",
              "tier": null,
              "xref": null
            }
          ]
        },
        {
          "ku": "Logic Programming",
          "tiers": {
            "tier": "Elective",
            "hours": null
          },
          "topics": [
            {
              "topic": "Clausal representation of data structures and algorithms",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Unification",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Backtracking and search",
              "tier": null,
              "subtopics": []
            },
            {
              "topic": "Cuts",
              "tier": null,
              "subtopics": []
            }
          ],
          "hours": [],
          "outcomes": [
            {
              "number": "1",
              "outcome": "Use a logic language to implement a conventional algorithm.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            },
            {
              "number": "2",
              "outcome": "Use a logic language to implement an algorithm employing implicit search using clauses, relations, and cuts.",
              "mastery": "Usage",
              "tier": null,
              "xref": null
            }
          ]
        }
      ],
      "references": []
    }
  ]
}